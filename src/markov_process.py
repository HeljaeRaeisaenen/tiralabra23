from random import choices
from itertools import accumulate
from trie import Trie
import constants
from read_file import split_into_words
quote_test = []


class Markov:
    '''Class that does Markov process.
    Attributes:
        trie: a populated trie structure that contains the rules of the process
        open_quote: boolean, this indicates whether the sentence being generated has
        an unclosed quotation mark or not.'''

    def __init__(self, trie: Trie) -> None:
        self.trie = trie
        self._open_quote = False

    def generate_sentence(self, start: str, degree: int):
        '''Creates sentence using a Markov process.
        Args:
            start: a word or words that are to start the sentence
            degree: which degree of process to use
        Returns:
            a string sentence generated by the process'''

        word = self.validate_starting_word(start)
        #print('starting word:', word)
        if not word:
            return False
        wordlen = len(word)

        generated_sentence = word
        rule = word[-degree:]
        quote_test.append(self._open_quote)

        while True:
            next_words = self.trie.search(rule)
            if not next_words:
                break

            # for node in next_words:
            #    print('     next node:', node.value)

            weights = self.calculate_weights(next_words)

            for i in range(len(next_words)):
                # the range gives the code a chance to choose another word
                # if the word chosen is an unwanted quote mark
                chosen_one = choices(next_words, cum_weights=weights, k=1)[0]
                # print('chosen: ', chosen_one.value, chosen_one.freq)
                if chosen_one.value == '“':
                    if not self._open_quote:
                        self.flip_quote_flag()
                        break
                elif chosen_one.value == '”':
                    if self._open_quote:
                        self.flip_quote_flag()
                        break
                else:
                    break

            generated_sentence.append(chosen_one.value)
            quote_test.append(self._open_quote)
            rule = generated_sentence[-degree:]

        print(quote_test)
        if len(generated_sentence) == wordlen:
            print('\nThe program made a mistake :(')

        return self.format_sentence(generated_sentence)

    def calculate_weights(self, nodes):
        '''Determine which of the words does appear more often and should thus be favoured.
        Args:
            nodes: list of trie nodes, representing next possible words in the Markov chain
        Returns:
            probabilities: list of the relative probabilities of each word, calculated by how often
            they have appeared in their context in the source material. used as weights in a random
            choice'''
        probabilities = [0]*len(nodes)

        index = 0
        for node in nodes:
            probabilities[index] = node.freq
            index += 1

        total = sum(probabilities)

        for index in range(0, len(nodes)):
            probabilities[index] = probabilities[index] / total
        probabilities = list(accumulate(probabilities))
        return probabilities

    def validate_starting_word(self, start):
        '''Make sure the starting word/-s is/are in the alphabet, and turn them into a list
        Args:
            start: string containing the starting word(s)
        Returns:
            list containing the starting word(s)'''

        if len(start) == 0:
            start = self.random_word()
        # print('starting word:', start)
        start = split_into_words(start)
        # print('starting word split:', start)

        validated = []
        for word in start:
            if word not in constants.ALPHABET:
                if word.lower() in constants.ALPHABET:
                    validated.append(word.lower())
                else:
                    return False
            else:
                if word == '“' or '"' in word:
                    self.flip_quote_flag()
                validated.append(word)

        return validated

    def format_sentence(self, sentence: list):
        '''Turn the generated list of words into a string structured like a sentence
        Args:
            sentence: list of strings
        Returns:
            a pretty string'''
        sentence[0] = sentence[0].capitalize()

        output = sentence[0]
        for word in sentence[1:]:
            if word in ',.;:?!"“”':
                output += word
            else:
                output += ' ' + word

        if self._open_quote:
            output += '”'

        return output

    def random_word(self):
        '''Get a random word of the alphabet that can start a three-word sequence.
        Returns: string'''
        possible_starts = self.trie.root.give_children()
        chosen = choices(possible_starts, k=1)[0]

        return chosen.value

    def flip_quote_flag(self):
        self._open_quote = not self._open_quote


if __name__ == '__main__':
    pass
